---
title:  <span style="color:Red"> Statistical Graphics <span>
author: "Dhruv Patel"
date: "12/08/2019"
output: slidy_presentation
   
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---

### Base Graphics

When graphing for the first time with R, most people use base graphics and then move on to ggplot2 when their needs become more complex. Base graphics are just needed, especially for modifying the plots generated by other functions. In this section we will discuss about:

* Base Histograms
* Base Scatterplot
* Boxplots

Also, instead of using tiny datasets build into R, we will use data sets included with ggplot2. It can be accessed as shown below:

```{r,warning=FALSE,message=FALSE}
require(ggplot2)
data(diamonds)
head(diamonds)
```

---

### Base Histograms

The most common graph of data in a single variable is a histogram. This shows the distribution of values for that variable. Creating a histogram is very simple as shown below:

```{r}
hist(diamonds$carat, main = "Carat Histogram", xlab = "Carat")
```

---

It is also possible to build a scatterplot by simply specifying the x and y variables without the formula interface. This allows plotting of variables that are not necessarily in a data.frame.

```{r}
plot(diamonds$carat, diamonds$price)
```

---

### Boxplots

Although boxplots are often among the first graphs taught to statistics students, they are a matter of great debate in the statistics community. Given their ubiquity (deserved or not) it is important to learn them.

R has boxplot function for this purpose:

```{r}
boxplot(diamonds$carat)
```

The idea behind the boxplot is that the thick middle line represents the median and the box is bounded by the first and third quartiles. That is, the middle 50% of data (the Interquartile Range or IQR) is held in the box. The lines extend out to 1.5*IQR in both directions. Outlier points are then plotted beyond that. It is important to note that while 50% of the data are very visible in the box, that means 50% of the data are not really displayed. That is a lot of information to not see.

---

### ggplot2

While R's base graphics are extremely powerful and flexible and can be customized to a great extent, using them can be labor intensive. Two packages-ggplot2 and lattice-were built to make graphing easier. Over the past few years ggplot2 has far exceeded lattice in popularity and features.

Initially, the ggplot2 syntax is harder to grasp, but the effort is more than worthwhile. It is much easier to delineate data by color, shape, or size and add legends with ggplot2. Graphs are quicker to build. Graphs that could take 30 lines of code with base graphics are possible with just one line in ggplot2.

The basic structure for ggplot2 starts with the ggplot function, which at its most basic should take the data as its first argument. It can take more arguments, or fewer, but we will stick with that for now. After initializing the object, we add layers using the + symbol. To start, we will just discuss geometric layers such as points, lines and histograms. They are included using functions like geom point, geom line and geom histogram. These functions take multiple arguments, the most important being which variable in the data gets mapped to which axis or other aesthetic using aes. Furthermore, each layer can have different aesthetic mappings and even different data.

---

### ggplot2 Histograms and Densities

Let us recreate the histogram of previous section. We plot the distribution of diamond carats using ggplot2. This is built using ggplot and geom histogram. Because histograms are one-dimensional displays of data, we need to specify only one aesthetic mapping, the x-axis.

```{r}
ggplot(data = diamonds) + geom_histogram(aes(x = carat))
```

---

A similar display is the density plot, which is done by changing geom histogram to geom density. We also specify the color to fill in the graph using the fill argument. This differs from the color argument that we will see later. Also notice that the fill argument was entered outside the aes function. This is because we want the whole graph to be that color.

```{r}
ggplot(data = diamonds) + geom_density(aes(x = carat), fill = "grey50")
```

Whereas histograms display counts of data in buckets, density plots show the probability of observations falling within a sliding window along the variable of interest. The difference between the two is subtle but important. Histograms are more of a discrete measurement while density plots are more of a continuous measurement.

---

### ggplot2 Scatterplots

We start by re-creating the simple scatterplot in previous section. Like before, we use ggplot to initialize the object, but this time we include aes inside the ggplot call instead of using it in the geom. The ggplot2 version is shown below:

```{r}
ggplot(diamonds, aes(x = carat, y = price)) + geom_point()
```

---

In the next few examples we will be using ggplot(diamonds, aes(x=carat, y=price)) repeatedly, which ordinarily would require a lot of redundant typing. Fortunately we can save ggplot objects to variables and add layers later. We will save it to g.

```{r}
# save basics of ggplot object to a variable
g <- ggplot(diamonds, aes(x = carat, y = price))
```

Notice that nothing is plotted.

---

Going forward we can add any layer to <b>g</b>.

The diamonds data have many interesting variables we can examine. Let's first look at color, which we will map to the color4 aesthetic.

```{r}
g + geom_point(aes(color = color))
```

---

Notice that we set color=color inside aes. This is because the designated color will be determined by the data. Also see that a legend was automatically generated. Recent versions of ggplot2 have added flexibility with the legend, which we will discuss later.

ggplot2 also has the ability to make faceted plots, or small multiples as Edward Tufte would say. This is done using  facet wrap or facet grid. facet wrap takes the levels of one variable, cuts up the underlying data according to them, makes a separate pane for each set, and arranges them to fit in the plot as shown below:

```{r}
g + geom_point(aes(color = color)) + facet_wrap(~color)
```

---

Here the row and column placement have no real meaning. facet grid acts similarly but assigns all levels of a variable to either a row or column as shown in below:

```{r}
g + geom_point(aes(color = color)) + facet_grid(cut ~ clarity)
```

In this case the upper left pane displays a scatterplot where the data are only for diamonds with Fair cut and  I1 clarity. The pane to the right is a scatterplot where the data are only for diamonds with Fair cut and  SI2 clarity. The pane in the second row, first column is a scatterplot where the data are only for diamonds with  Good cut and I1 clarity. After understanding how to read one pane in this plot we can easily understand all the panes and make quick comparisons.

---

Faceting also works with histograms or any other geom as shown in figure below:

```{r}
ggplot(diamonds, aes(x = carat)) + geom_histogram() + facet_wrap(~color)
```

---

### ggplot2 Boxplots and Violins Plots

Being a complete graphics package, ggplot2 offers a boxplot geom through geom boxplot. Even though it is one-dimensional, using a y aesthetic, there needs to be some x aesthetic, so we will use 1.

```{r}
ggplot(diamonds, aes(y = carat, x = 1)) + geom_boxplot()
```

---

This is neatly extended to drawing multiple boxplots, one for each level of a variable, as shown below:

```{r}
ggplot(diamonds, aes(y = carat, x = cut)) + geom_boxplot()
```

---

Getting fancy, we can swap out the boxplot for violin plots using geom violin as shown below:

```{r}
ggplot(diamonds, aes(y = carat, x = cut)) + geom_violin()
```

---

Violin plots are similar to boxplots except that the boxes are curved, giving a sense of the density of the data. This provides more information than the straight sides of ordinary boxplots.

We can use multiple layers (geoms) on the same plot. Notice that the order of the layers matters. In the graph on the left, the points are underneath the violins, while in the graph on the right, the points are on top of the violins.

```{r}
ggplot(diamonds, aes(y = carat, x = cut)) + geom_point() + geom_violin()
```

---

```{r}
ggplot(diamonds, aes(y = carat, x = cut)) + geom_violin() + geom_point()
```

---

### ggplot2 Line Graphs

Line charts are often used when one variable has a certain continuity, but that is not always necessary because there is often a good reason to use a line with categorical data. Here is an example of a line plot using the economics data from  ggplot2. ggplot2 intelligently handles dates and plots them on a logical scale.

```{r}
ggplot(economics, aes(x = date, y = pop)) + geom_line()
```

---

### ggplot2 Line Graphs

Line charts are often used when one variable has a certain continuity, but that is not always necessary because there is often a good reason to use a line with categorical data. Here is an example of a line plot using the economics data from  ggplot2. ggplot2 intelligently handles dates and plots them on a logical scale.

```{r}
ggplot(economics, aes(x = date, y = pop)) + geom_line()
```

---

While this worked just fine, it is sometimes necessary to use aes(group=1) with geom line. Yes, it is hacky, but it gets the job done, just like when plotting a single boxplot. It is a quirk of ggplot2 that sometimes lines cannot be plotted without a group aesthetic.

A common task for line plots is displaying a metric over the course of a year for many years. To prepare the economics data we will use Wickham's lubridate package, which has convenient functions for manipulating dates. We need to create two new variables, year and month. To simplify things we will subset the data to include only years starting with 2000.

```{r}
# load the lubridate package
require(lubridate)
## create year and month variables
economics$year <- year(economics$date)
# the label argument to month means that the result should be the
# names of the month instead of the number
economics$month <- month(economics$date, label=TRUE)
# subset the data
# the which function returns the indices of observations where the
# tested condition was TRUE
econ2000 <- economics[which(economics$year >= 2000), ]
# load the scales package for better axis formatting
require(scales)
```
  
Also note the use of which to subset the data. This is similar to a where clause in SQL.

---

```{r}
# build the foundation of the plot
g <- ggplot(econ2000, aes(x=month, y=pop))
# add lines color coded and grouped by year
# the group aesthetic breaks the data into separate groups
g <- g + geom_line(aes(color=factor(year), group=year))
# name the legend "Year"
g <- g + scale_color_discrete(name="Year")
# format the y axis
g <- g + scale_y_continuous(labels=comma)
# add a title and axis labels
g <- g + labs(title="Population Growth", x="Month", y="Population")
# plot the graph
g
```

---

### Themes

A great part of ggplot2 is the ability to use themes to easily change the way plots look. While building a theme from scratch can be daunting, Jeffrey Arnold from the University of Rochester has put together ggthemes, a package of themes to re-create commonly used styles of graphs. Just a few styles-The Economist, Excel, Edward Tufte and The Wall Street Journal-are exhibited in figure below:

```{r}
require(ggthemes)
# build a plot and store it in g2
g2 <- ggplot(diamonds, aes(x=carat, y=price)) + geom_point(aes(color=color))
# apply a few themes
g2 + theme_economist() + scale_colour_economist()
```

---

```{r}
g2 + theme_excel() + scale_colour_excel()
```

---

```{r}
g2 + theme_tufte()
```

---

```{r}
g2 + theme_wsj()
```

---

### Conclusion

We have seen both basic graphs and ggplot graphs that are both nicer and easier to create. We have covered histograms, scatterplots, boxplots, line plots and density graphs. We have also looked at using colors and small multiples for distinguishing data. There are many other features in ggplot2 such as jittering, stacking, dodging and alpha, which we will demonstrate in context throughout the book.

